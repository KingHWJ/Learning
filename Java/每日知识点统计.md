

###  运算符

- 算术运算符
  - 自增自减运算符
  - 前缀式和后缀式
- 关系操作符
  - == 和 !=
  - equals()
    - 默认比较的是引用
    - 若要比较值，需要覆盖重写该方法
- 逻辑操作符
- 直接常量
- 按位操作符
- 移位操作符
- 三元操作符
- 字符串操作符 + 和 +=
- 类型转换操作符

### ArrayList

- ArrayList的基本使用
- 常用方法
  - add
  - remove
  - get
  - size
- 存储基本类型数据的使用 和 包装类

### 字符串

- 字符串的几种创建方法（3+1）

- 字符串的特点

- 字符串的常量池

- 字符串的常用方法

  - 比较
    - equals
    - equalsIgnorecase
  - 获取
    - length
    - charAt
    - concat
    - indexOf
  - 截取
    - substring（int begin)
    - substring（int begin，int end)

  - 转化
    - toCharArray
    - getBytes
    - replace （CharSequence的概念）
  - 分割
    - split

### static 关键字

- 基本含义
- static 中的计算器作用
- 修饰成员变量
- 修饰成员方法
- 静态方法的几种使用方法
- 静态与成员之间的访问关系
  - 静态不能访问非静态
  - 静态方法中不能使用this
- 静态代码块
  - 执行顺序
  - 执行次数

### Arrays类

- toString
- sort

### Math

- abs
- ceil
- floor
- round

### 类初始化顺序

1. 父类静态变量 + 静态代码块
2. 子类静态变量 + 静态代码块
3. 父类成员变量 + 非静态代码块
4. 父类构造函数
5. 子类成员变量 + 非静态代码块
6. 子类构造函数

### 继承

- 定义

- 共性抽取

- 特点

- 父类与子类，变量访问规则

- 变量的重名规则

- 方法覆盖重写

  - super 关键字
  - 父类与子类的方法名和参数列表一样
  - @Overwride
  - 返回值范围
  - 权限值范围
  - 构造方法中的super访问特点
    - **子类构造方法时，必须先调用父类的构造方法**
    - 理解：继承关系，在内存中，先产生父类，再产生子类
  - super关键字的三种用法总结

- 继承的三个特点

> 继承案例：发红包
>
> ##### 准备：
>
> - 用户类
>   - 属性
>     - 姓名
>     - 钱包余额
>   - 方法
>     - 展示余额
> - 群主类
>   - 属性：父类属性
>   - 方法：
>     - 父类方法
>     - 发红包方法
>       - 返回值类型：ArrayList<Interger>
>       - 名称：send
>       - 参数列表：人数，总额
> - 成员类
>   - 属性：父类属性
>   - 方法：
>     - 父类方法
>     - 收红包方法
>       - 返回值类型：void
>       - 名称：receive
>       - 参数列表：红包ArrayList<Interger>
>
> ##### 要点
>
> - 群主发红包前，进行余额检测
> - 发红包后，钱包余额要进行相应的扣除
> - 群员收红包，随机取一个
> - 群员收红包，余额进行相加



### 抽象方法和抽象类

- 基本概念

- 定义方法（abstract）

- 使用方法

- 注意事项

  - 抽象类不一定有抽象方法，当抽象方法所在的类一定是抽象类
  - 抽象类无法直接new对象

  

### 接口

- 什么是接口？
- Java接口中可以包含的内容
- 接口的使用步骤
- 接口中的方法使用
  - 抽象方法
  - 默认方法
  - 静态方法
  - 私有方法
    - 普通私有方法
    - 静态私有方法
  - 成员变量
- 一个实现类可以继承多个接口
- 接口之间的多继承

### 多态

- 定义和条件
- 使用
- 成员变量和成员方法的使用规则
- 多态的优点
- 对象的向上转型（父类名称 对象吗 = new 子类名称( )  ）
- 对象的向下转型 【还原】（子类名称 对象名 = （子类名称）父类对象）
- instanceof 类的使用，判断某个对象本来的类是不是

### 内部类

- final关键字（类，方法，变量）
- 四种权限修饰符（public protected default private）
- 概念：一个事务内部包含另一个事务
- 分类
  - 成员内部类
  - 局部内部类（包含匿名内部类）
  - 匿名内部类
- 使用方式
  - 间接使用
  - 直接使用
- 重名情况，成员变量访问

### Object类

- toString方法
  - 默认打印的是地址值
  - 判断一个类有没有重写该方法，即看打印的是不是地址值，不是则重写了
- equals方法
  - ==
    - 基本数据类型，比较的是指
    - 引用类型，比较的是地址值
  - Objects.equals() 可以规避空指针

### Date类 （抽象类）

表示特定的时间瞬间，精确到毫秒

- 时间概念（0毫秒）
- 0时区，中国要加8个小时（东八区）
- getTime()
- DateFormat
- SimpleDateformat
- 日期格式字母
- 解析异常

### Calendar类（抽象类）

- getInstance( 
- set
- add
- getTime

### System类

- CurrentTiemMills (返回以毫秒为单位的当前时间)

- arraycopy (将数组指定的数据拷贝到另一个数组)

  - arrayCopy(源数组，开始位置，目标数组，开始位置，复制长度)
  - 超出数组长度会报错

### StringBuilder类

- String类
  - 字符串是常量：他们的值在创建之后不能改变
  - 字符串的底层是一个被final修饰的数组
- StringBuilder类
  - 字符串缓冲区，提高字符串的操作效率（看成可以改变的字符串）
  - 底层也是一个数组，但没有被final修饰
  - byte[] val = new byte[16] 初始是16
  - 如果超出，会自动扩容
  - 链式编程
  - ![image-20200902103827727](/Users/laohangdeche/Library/Application Support/typora-user-images/image-20200902103827727.png)
  - StringBuilder(String Str) ---> 把一个字符串转换成一个StringBuilder类
  - toString() ---> 把一个StringBuilder类转换成一个String类

### 包装类

- 概念：基本类型数据无法直接操作，使用一个类直接把基本数据类型包装起来，以便好操作

- 基本类型 -- 对应的包装类型

  - ```
    byte    ---->  Byte
    char    ---->  Character
    short   ---->  Short
    int     ---->  Integer
    long    ---->  Long
    float   ---->  Float
    double  ---->  Double
    boolean ---->  Boolean
    ```

- 装箱与拆箱

  - 装箱：把基本数据类型，包装到包装类中
  - 拆箱：从包装类中，取出基本类型数据

- 自动装箱与自动拆箱

  - 自动装箱：直接把int类型数据，赋值给包装类（Integer in = 1;)
  - 自动拆箱：in是 包装类，无法直接参与运算，可以自动转换为基本类型，再参与计算

- 基本类型与字符串之间的转换

  - 基本类型 ———> 字符串
    - 基本类型数据 +  "" (常用)
    - 包装类中的静态方法 static String toString(int i)
    - String中的静态方法 static String valueOf(int i)
  - 字符串 ———> 基本类型
    - 包装类中的静态方法 parseXX("字符串")	(除了character类)
      - 字符串必须是对应数据的格式

### Collection集合

- 概念：一种容器，存储多个数据
- 和数组的区别
  - 数组的长度是固定的，集合的长度是可变的
  - 数组存储的数据是同一类型的，可以存储基本类型，也可以存储对象；而集合只能存储对象
- 集合框架：![image-20200902152208856](/Users/laohangdeche/Library/Application Support/typora-user-images/image-20200902152208856.png)
- 常用功能方法（共性方法）
  - add
  - clear
  - remove
  - contains
  - isEmpty
  - size
  - toArray

### Iterator迭代器

- 迭代：取元素之前，先判断，如果有，就取出来，继续判断，

- 两个方法
  - hasNext()	判断集合中还有没有下一个元素，有则返回true
    - next()    取出集合中的下一个元素
  
- 使用：
  - Iterator迭代器，是一个接口，我们无法直接使用，需要使用Iterator接口的实现类对象
  - Collection接口中有一个方法，叫iterator（），这个方法返回单值就是迭代器的实现类对象
  
- 增强for循环（for each）

  - 遍历集合和数组

  - ```java
    for (集合/数组的数据类型 变量名 : 集合名/数组名){
     		使用（变量名）
    }
    ```

### 泛型

- 概念：未知的数据类型，当我们不知道使用什么数据类型，可以使用泛型

- 不使用泛型：优缺点：

  - 好处：集合不使用泛型，默认的类型就是object类型，可以存储任意类型的数据
  - 弊端：不安全，引发异常

- 使用泛型：

  - 好处：
    - 避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型
    - 把运行期的异常，提升到了编译器（写代码就会报错）
  - 弊端：
    - 泛型是什么类型，只能存储什么类型的数据

- 泛型的定义和使用

  ```java
  public class FanXing<E> {
      private E name;
      public FanXingTest() {
      }
      public E getName() {
          return name;
      }
      public void setName(E name) {
          this.name = name;
      }
  }
  ```

- 含有泛型的方法
  - public <E> void method(E e) { }
  - public static <E> void method(E e) { }
  
- 含有泛型的接口
  - 在接口实现类中，指定具体的类型
  - 在接口实现类创建对象时。再指定具体的类型
  
- 泛型通配符<?>

- 泛型的上限限定   <? extends Integer>   只能接收Integer类型和其子类

- 泛型的下限限定   <? super Integer>      只能接收该类型和其父类

### 数据结构

#### 栈 （先进后出）

#### 队列 （先进先出）

#### 数组（查询快，增删慢）

- 查询快（地址是连续的，通过数组首地址可以找到数组，通过索引可以快速查找某一个数据）
- 增删慢（数组的长度是固定的，我们想要增加/删除一个元素，必须创建一个新数组，把源数组的数据复制过来）

#### 链表（查询慢，增删快）

- 查询慢（链表中地址不是连续的，每次查询元素，都必须从头开始查询）
- 增删快（链表结构，增删数据，对链表结构没有影响）
- 单向链表和双向链表

#### 数据结构

- 二叉树
- 排序树/查找树
- 平衡树
- 不平衡树
- 红黑树
  - 结点是红色或黑色
  - 根节点是黑色
  - 每个叶子结点都是黑色的空节点（NIL结点）
  - 每个红色结点的两个子节点都是黑色
  - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色结点

### List接口

- 特点
  - 有序的集合
  - 有索引
  - 允许重复
  - 含有索引特有方法
    - add(index,e)
    - remove(index)
    - set(index,e)  -- 替换
    - get(index)
- 子类
  - ArrayList
    - 底层是数组结构，查询快，增删会重新复制一个数组进行操作
  - LinkdList
    - 链表结构
    - 特点
      - 底层是链表结构，查询慢，增删快
      - 包含大量首尾元素方法
      - 特有方法不能使用多态
    - getFirst()
    - getLast()
    - addFirst 和 push
    - addLast 和 add
    - removeFirst
    - removeLast
    - pop

### Set接口

- 特点
  - 不允许重复元素
  - 没有索引，无带索引的办法
- HashSet
  - 不允许重复
  - 没有索引
  - 无序集合
  - 底层是一个哈希表结构（查询速度非常快）
- 哈希值（十进制的整数，系统随机给出）
  - hashCode的值是不是具体的地址值
- 哈希冲突
- 哈希表
  - 数组结构，把元素进行分组（相同的哈希值的元素是一组的）
  - 哈希表 =  数组 + 红黑树（jdk1.8之前是链表）
- set集合不重复的原理（前提，必须重写hashCode方法和equals方法）
  - add方法，会调用hashCode方法，计算哈希值
  - 在集合中查询，是否有同样哈希值的数据
    - 没有，则添加进集合中
    - 有，则发生哈希冲突。则调用equals()方法，比较哈希值
      - 如果equals（） ,返回true，认定两个数据重复
      - 如果返回false，则认定数据不重复，则添加到集合中去
- 利用hashSet存储自定义类型元素
  - 重写hashCode方法
  - 重写equals方法
- LinkedHashSet接口
  - 底层是一个哈希表（数组+链表/红黑树）+ 链表：多一条链表（记录元素顺序）
- 可变参数：
  - 参数列表的数据类型已确定，但是参数的个数不确定
  - 原理：
    - 就是一个数组，根据参数个数不同，会创建不同长度的数组，来存储这些参数
  - 格式：修饰符 返回值 函数名（参数类型...参数名）
  - 参数默认是一个长度为0的空数组
  - 注意事项：
    - 方法参数列表，只能有一个可变参数
    - 如果有多个参数，那可变参数一定要在末尾
  - 可变参数终极写法：
    - public static void method(Object...obj)
    - 即可以传入任意类型的参数

### Collections常用功能

- addAll( )	-- 静态方法
- shuffle( )    --打乱集合顺序
- sort( ) -- 将集合中元素按照默认规则排序
  - 默认是升序
  - sort使用前提：集合中的元素，必须重写接口中的Comparable方法 ，定义排序规则
    - comparable规则
      - 自己（this) - 参数 // 升序
      - 参数 - 自己（this) // 降序
- sort（list，comparator） 指定规则进行排序
  - comparable :自己 和 参数 进行比较
    - 非集合对象比较，需要重写compareTo方法
  - compartor：找一个第三方裁判，进行比较

### Map集合

- 特点
  - 是一个双列集合，一个key 和 一个value 
  - key和value的数据类型可以相同，也可以不同
  - key是不允许重复的，value是可以重复的
  - key和value是一一对应的
- 子类
  - HashMap	（无序）
    - 底层是哈希表，查询速度很快（数组+单向链表/红黑树）
  - LinkedHashMap （有序）
    - 继承了HashMap
    - 底层是哈希表 + 链表
- 常用方法
  - put（key，value)
    - 如果key不存在，返回null
    - 如果存在，返回最新的value
  - remove（key)
    - 同上
  - get（key)
    - 同上
  - containsKey（key)
    - 包含，返回true
    - 不包含，返回false
  - keySet()
    - 将map中的key取出来，放进set集合中
  - entrySet() -- 返回Set(Map.Entry<k,v>)
    - Entry记录键值对
    - getKey() 获取key
    - getValue() 获取值
  - HashMap存储自定义类型，作为键值的话，一定要重写hashCode方法和equals方法
- Hashtable
  - 特点
    - 任何一个非null对象都可以作为键和值，即不能存储null值
    - 单线程集合
    - Hashtable和vector集合都被更先进的集合取代了
- jdk9 新方法
  - of（） 静态方法
  - List，Set,Map,给集合一次性添加多个元素
  - 使用前提：
    - 当集合中存储的元素个数已经确定了，不在改变使用
  - of方法的返回值是一个不能改变的集合
  - Set和Map在调用of方法的时候，不能有重复的元素，否在会抛出异常（非法参数异常）

### 异常

- 概念：程序执行过程中，出现非正常情况，导致jvm非正常的停止
  - 异常并不是语法错误，语法错误，根本不能通过编译
- 异常体系
  - Throwable
    - Error
    - Exception
- 异常和错误
  - 异常分类
    - Exception：编译期异常
    - RuntimeException：运行期异常
  - 错误：无法治愈，必须修改源代码
- 异常产生过程解析
  - jvm会根据异常产生的原因，产生一个异常对象（包含，异常的原因，内容，位置）
  - 方法中，没有异常的处理逻辑，那么jvm会把问题抛出给方法调用者main方法
  - main方法中没有解决办法，将异常抛出给jvm
  - jvm接受到异常对象，以红色的字体打印在控制台
  - jvm会终止当前正在执行的java程序--> 终端处理
- throw关键字
  - 在指定的方法中，抛出指定的异常
  - 格式：throw new xxxException("异常产生的原因")
  - 注意：
    - throw关键字必须写在方法内部
    - throw关键字后边new的对象必须是Exception或者Exception子类对象
    - throw关键字抛出指定的异常对象，我们就必须处理这个异常对象
      - throw关键字后边创建的是RuntimeException或者RuntimeException的子类对象，我们可以不处理，默认交给jvm处理（打印异常对象，中断程序）
      - throw后面创建的是编译异常，我们就必须处理这个异常，要么throws，要么try...catch
    - 在工作中，我们首先要对传过来的参数，做合法性校验
- objects，静态方法，非空判断
  - requireNonNull（obj,msg)
- throws 声明异常
  - 必须写在方法声明处
- try...catch
  - 自己处理异常
  - try可能会抛出多个异常，可以使用catch来处理这些异常
- finally 代码块
  - 不能单独使用
  - 一般用于资源释放（资源回收），无论程序是否出现异常，资源都需要释放
  - finally 中的代码块是一定会被执行的
- Throwable类的三个方法
  - String getMessage() （错误的简单描述）
  - String StoString()
  - void printStackTrace() (非常详细的错误信息)
- 多异常捕获
  - 一次捕获，多长处理（一次try，多次catch）
    - catch里定义的异常变量， 如果存在子父类关系，那么子类应该写在上面
  - 多个异常，一次捕获，一次处理
    - try{} catch(Exception e){}
- 注意事项
  - 如果finally中有return语句，则永远返回finally中的结果
  - 子父类的异常
    - 父类异常是什么样，子类异常就是什么样
    - 父类抛出多个异常，子类重写方法时，也要抛出和父类相同的异常，或者父类异常的子类，或者不抛出异常
    - 父类没有抛出异常，子类重写父类该方法也不可以抛出异常，如果子类抛出异常，需要自己捕获处理，不能声明抛出
- 自定义异常
  - java提供的异常类，不够自己使用，我们需要自己定义
  - public xxxxException extends Exception/RuntimException
    - 添加一个空参数构造方法
    - 添加一个带异常信息的构造方法
      - 方法内部都会调用父类异常信息的构造方法 super()

### 多线程

- 并发与并行
  - 并发：交替执行（在同一时间段发生）
  - 并行：同时执行（在同一时刻发生）
- 线程和进程
  - 进程，一个程序都要进入内存中运行，进入到内存的程序叫进程
  - 线程，线程是进程中的一个执行单元
- 单核心单线程cpu
  - cpu在多个线程之间做高速的切换，轮流执行多个任务，切换速度（1/n毫秒）
  - 多核心多线程cpu
- 线程调度
  - 分时调度
  - 抢占式调度（java的线程模式）
- 主线程
  - 执行主方法(main)的线程
  - 程序是从main方法，从上到下执行
- 线程创建
  - java.lang.Thread类
  - 创建一个Thread类的子类
  - 在Thread子类中重写Thread中的run方法，设置线程任务
  - 多次启动一个线程是非法的
- 多线程原理
  - jvm执行main方法开辟通往cpu的路径，叫main线程，主线程，main方法通往cpu
  - .start() 会开辟新的栈空间，来执行run方法
  - new Thread() 开辟一条通往cpu的新路径，新线程
  - 两个线程来抢夺cpu的执行权（执行时间）
  - 多线程的好处，多线程之间互不影响（有自己的内存空间）
- 方法
  - getName
  - setName
  - currentThread
  - sleep（毫秒） 当前进程睡眠一段时间
- 创建线程的第二个方法 Runnable接口
  - 创建一个Runnable接口的实现类
  - 在实现类中重写接口的run方法
  - 创建Thread类对象，构造方法中传递接口类的实现类对象
- Thread和Runnable 接口的区别
  - 实现了Runnable接口好处
    - 避免了单继承的局限性
      - 类继承了Thread类就不能继承其他的类
    - 增强了程序的扩展性
      - 设置线程任务和开启线程任务进行了分离（解耦）
- 匿名内部类实现线程的方式（作用：简化代码）

### 线程安全

- 概念：
  - 单线程程序不会出现线程安全问题
  - 多线程序没有访问共享数据，不会产生问题
  - 多线程访问共享数据，会产生线程安全问题
- 线程安全那问题出错原理
  - 睡眠会失去cpu的执行权，有可能程序未执行完，就切换到其他程序、
- 解决方法
  - 同步代码块（synchronized)
    - 原理：使用了一个锁对象，这个对象叫同步锁，也叫对象监视器
    - 线程运行之前，会检测有没有锁对象，没有则进入阻塞状态
    - 同步中的线程，没有执行完不会释放锁，同步外的线程没有锁不会进去同步
  - 同步方法
    - synchronized实现类对象
    - 静态同步方法
      - 静态方法的锁对象是本类的class属性
  - Lock（接口）
    - ReentrantLock实现类
    - lock	  获取锁
    - unlock  释放锁 

 ### 线程状态

- NEW（新建状态)
- RUNABLE（运行状态）
- BLOCKED （阻塞状态）
  - 没有争取到锁对象，进入阻塞状态
- TERMINATED（死亡状态）
- TIMED_WAITING（休眠状态）
  - 调用sleep方法后，计时等待
- WAITING（无限等待状态）
  - 线程之间的通信
  - 一个线程需要调用wait方法，进入等待状态
  - 一个线程处理完后需要调用notify方法，唤醒另一个线程
  - 这两个线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个执行
  - 只有锁对象才能使用wait和notify方法
  - wait (ms) 如果超过毫秒时间内，没有唤醒，则会自动唤醒
  - notifyAll() 唤醒所有等待线程