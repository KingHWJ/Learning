### ArrayList

- ArrayList的基本使用
- 常用方法
  - add
  - remove
  - get
  - size
- 存储基本类型数据的使用 和 包装类

### 字符串

- 字符串的几种创建方法（3+1）

- 字符串的特点

- 字符串的常量池

- 字符串的常用方法

  - 比较
    - equals
    - equalsIgnorecase
  - 获取
    - length
    - charAt
    - concat
    - indexOf
  - 截取
    - substring（int begin)
    - substring（int begin，int end)

  - 转化
    - toCharArray
    - getBytes
    - replace （CharSequence的概念）
  - 分割
    - split

### static 关键字

- 基本含义
- static 中的计算器作用
- 修饰成员变量
- 修饰成员方法
- 静态方法的几种使用方法
- 静态与成员之间的访问关系
  - 静态不能访问非静态
  - 静态方法中不能使用this
- 静态代码块
  - 执行顺序
  - 执行次数

### Arrays类

- toString
- sort

### Math

- abs
- ceil
- floor
- round

### 继承

- 定义

- 共性抽取

- 特点

- 父类与子类，变量访问规则

- 变量的重名规则

- 方法覆盖重写

  - super 关键字
  - 父类与子类的方法名和参数列表一样
  - @Overwride
  - 返回值范围
  - 权限值范围
  - 构造方法中的super访问特点
    - 子类构造方法时，必须先调用父类的构造方法
    - 理解：继承关系，在内存中，先产生父类，再产生子类
  - super关键字的三种用法总结

- 继承的三个特点

> 继承案例：发红包
>
> ##### 准备：
>
> - 用户类
>   - 属性
>     - 姓名
>     - 钱包余额
>   - 方法
>     - 展示余额
> - 群主类
>   - 属性：父类属性
>   - 方法：
>     - 父类方法
>     - 发红包方法
>       - 返回值类型：ArrayList<Interger>
>       - 名称：send
>       - 参数列表：人数，总额
> - 成员类
>   - 属性：父类属性
>   - 方法：
>     - 父类方法
>     - 收红包方法
>       - 返回值类型：void
>       - 名称：receive
>       - 参数列表：红包ArrayList<Interger>
>
> ##### 要点
>
> - 群主发红包前，进行余额检测
> - 发红包后，钱包余额要进行相应的扣除
> - 群员收红包，随机取一个
> - 群员收红包，余额进行相加



### 抽象方法和抽象类

- 基本概念

- 定义方法（abstract）

- 使用方法

- 注意事项

  - 抽象类不一定有抽象方法，当抽象方法所在的类一定是抽象类
  - 抽象类无法直接new对象

  

### 接口

- 什么是接口？
- Java接口中可以包含的内容
- 接口的使用步骤
- 接口中的方法使用
  - 抽象方法
  - 默认方法
  - 静态方法
  - 私有方法
    - 普通私有方法
    - 静态私有方法
  - 成员变量
- 一个实现类可以继承多个接口
- 接口之间的多继承

### 多态

- 定义和条件
- 使用
- 成员变量和成员方法的使用规则
- 多态的优点
- 对象的向上转型（父类名称 对象吗 = new 子类名称( )  ）
- 对象的向下转型 【还原】（子类名称 对象名 = （子类名称）父类对象）
- instanceof 类的使用，判断某个对象本来的类是不是

### 内部类

- final关键字（类，方法，变量）
- 四种权限修饰符（public protected default private）
- 概念：一个事务内部包含另一个事务
- 分类
  - 成员内部类
  - 局部内部类（包含匿名内部类）
  - 匿名内部类
- 使用方式
  - 间接使用
  - 直接使用
- 重名情况，成员变量访问

### Object类

- toString方法
  - 默认打印的是地址值
  - 判断一个类有没有重写该方法，即看打印的是不是地址值，不是则重写了
- equals方法
  - ==
    - 基本数据类型，比较的是指
    - 引用类型，比较的是地址值
  - Objects.equals() 可以规避空指针

### Date类 （抽象类）

表示特定的时间瞬间，精确到毫秒

- 时间概念（0毫秒）
- 0时区，中国要加8个小时（东八区）
- getTime()
- DateFormat
- SimpleDateformat
- 日期格式字母
- 解析异常

### Calendar类（抽象类）

- getInstance( 
- set
- add
- getTime

### System类

- CurrentTiemMills (返回以毫秒为单位的当前时间)

- arraycopy (将数组指定的数据拷贝到另一个数组)

  - arrayCopy(源数组，开始位置，目标数组，开始位置，复制长度)
  - 超出数组长度会报错

### StringBuilder类

- String类
  - 字符串是常量：他们的值在创建之后不能改变
  - 字符串的底层是一个被final修饰的数组
- StringBuilder类
  - 字符串缓冲区，提高字符串的操作效率（看成可以改变的字符串）
  - 底层也是一个数组，但没有被final修饰
  - byte[] val = new byte[16] 初始是16
  - 如果超出，会自动扩容
  - 链式编程
  - ![image-20200902103827727](/Users/laohangdeche/Library/Application Support/typora-user-images/image-20200902103827727.png)
  - StringBuilder(String Str) ---> 把一个字符串转换成一个StringBuilder类
  - toString() ---> 把一个StringBuilder类转换成一个String类

### 包装类

- 概念：基本类型数据无法直接操作，使用一个类直接把基本数据类型包装起来，以便好操作

- 基本类型 -- 对应的包装类型

  - ```
    byte    ---->  Byte
    char    ---->  Character
    short   ---->  Short
    int     ---->  Integer
    long    ---->  Long
    float   ---->  Float
    double  ---->  Double
    boolean ---->  Boolean
    ```

- 装箱与拆箱

  - 装箱：把基本数据类型，包装到包装类中
  - 拆箱：从包装类中，取出基本类型数据

- 自动装箱与自动拆箱

  - 自动装箱：直接把int类型数据，赋值给包装类（Integer in = 1;)
  - 自动拆箱：in是 包装类，无法直接参与运算，可以自动转换为基本类型，再参与计算

- 基本类型与字符串之间的转换

  - 基本类型 ———> 字符串
    - 基本类型数据 +  "" (常用)
    - 包装类中的静态方法 static String toString(int i)
    - String中的静态方法 static String valueOf(int i)
  - 字符串 ———> 基本类型
    - 包装类中的静态方法 parseXX("字符串")	(除了character类)
      - 字符串必须是对应数据的格式

### Collection集合

- 概念：一种容器，存储多个数据
- 和数组的区别
  - 数组的长度是固定的，集合的长度是可变的
  - 数组存储的数据是同一类型的，可以存储基本类型，也可以存储对象；而集合只能存储对象
- 集合框架：![image-20200902152208856](/Users/laohangdeche/Library/Application Support/typora-user-images/image-20200902152208856.png)
- 常用功能方法（共性方法）
  - add
  - clear
  - remove
  - contains
  - isEmpty
  - size
  - toArray

### Iterator迭代器

- 迭代：取元素之前，先判断，如果有，就取出来，继续判断，

- 两个方法
  - hasNext()	判断集合中还有没有下一个元素，有则返回true
    - next()    取出集合中的下一个元素
  
- 使用：
  - Iterator迭代器，是一个接口，我们无法直接使用，需要使用Iterator接口的实现类对象
  - Collection接口中有一个方法，叫iterator（），这个方法返回单值就是迭代器的实现类对象
  
- 增强for循环（for each）

  - 遍历集合和数组

  - ```java
    for (集合/数组的数据类型 变量名 : 集合名/数组名){
     		使用（变量名）
    }
    ```

### 泛型

- 概念：未知的数据类型，当我们不知道使用什么数据类型，可以使用泛型

- 不使用泛型：优缺点：

  - 好处：集合不使用泛型，默认的类型就是object类型，可以存储任意类型的数据
  - 弊端：不安全，引发异常

- 使用泛型：

  - 好处：
    - 避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型
    - 把运行期的异常，提升到了编译器（写代码就会报错）
  - 弊端：
    - 泛型是什么类型，只能存储什么类型的数据

- 泛型的定义和使用

  ```java
  public class FanXing<E> {
      private E name;
      public FanXingTest() {
      }
      public E getName() {
          return name;
      }
      public void setName(E name) {
          this.name = name;
      }
  }
  ```

- 含有泛型的方法
  - public <E> void method(E e) { }
  - public static <E> void method(E e) { }
- 含有泛型的接口
  - 在接口实现类中，指定具体的类型
  - 在接口实现类创建对象时。再指定具体的类型
- 泛型通配符<?>
- 泛型的上限限定   <? extends Integer>   只能接收Integer类型和其子类
- 泛型的下限限定   <? super Integer>      只能接收该类型和其父类